{"ast":null,"code":"import _asyncToGenerator from \"D:\\\\Users\\\\jenif\\\\Documents\\\\linguagens_prog\\\\javascript\\\\API - angular e nest\\\\estoque\\\\estoqueFront\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport platform from \"../platform/index.js\";\nimport utils from \"../utils.js\";\nimport AxiosError from \"../core/AxiosError.js\";\nimport composeSignals from \"../helpers/composeSignals.js\";\nimport { trackStream } from \"../helpers/trackStream.js\";\nimport AxiosHeaders from \"../core/AxiosHeaders.js\";\nimport { progressEventReducer, progressEventDecorator, asyncDecorator } from \"../helpers/progressEventReducer.js\";\nimport resolveConfig from \"../helpers/resolveConfig.js\";\nimport settle from \"../core/settle.js\";\nconst isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';\nconst isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function'; // used only inside the fetch adapter\n\nconst encodeText = isFetchSupported && (typeof TextEncoder === 'function' ? (encoder => str => encoder.encode(str))(new TextEncoder()) : /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (str) {\n    return new Uint8Array(yield new Response(str).arrayBuffer());\n  });\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}());\n\nconst test = (fn, ...args) => {\n  try {\n    return !!fn(...args);\n  } catch (e) {\n    return false;\n  }\n};\n\nconst supportsRequestStream = isReadableStreamSupported && test(() => {\n  let duplexAccessed = false;\n  const hasContentType = new Request(platform.origin, {\n    body: new ReadableStream(),\n    method: 'POST',\n\n    get duplex() {\n      duplexAccessed = true;\n      return 'half';\n    }\n\n  }).headers.has('Content-Type');\n  return duplexAccessed && !hasContentType;\n});\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\nconst supportsResponseStream = isReadableStreamSupported && test(() => utils.isReadableStream(new Response('').body));\nconst resolvers = {\n  stream: supportsResponseStream && (res => res.body)\n};\nisFetchSupported && (res => {\n  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n    !resolvers[type] && (resolvers[type] = utils.isFunction(res[type]) ? res => res[type]() : (_, config) => {\n      throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);\n    });\n  });\n})(new Response());\n\nconst getBodyLength = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (body) {\n    if (body == null) {\n      return 0;\n    }\n\n    if (utils.isBlob(body)) {\n      return body.size;\n    }\n\n    if (utils.isSpecCompliantForm(body)) {\n      const _request = new Request(platform.origin, {\n        method: 'POST',\n        body\n      });\n\n      return (yield _request.arrayBuffer()).byteLength;\n    }\n\n    if (utils.isArrayBufferView(body) || utils.isArrayBuffer(body)) {\n      return body.byteLength;\n    }\n\n    if (utils.isURLSearchParams(body)) {\n      body = body + '';\n    }\n\n    if (utils.isString(body)) {\n      return (yield encodeText(body)).byteLength;\n    }\n  });\n\n  return function getBodyLength(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nconst resolveBodyLength = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (headers, body) {\n    const length = utils.toFiniteNumber(headers.getContentLength());\n    return length == null ? getBodyLength(body) : length;\n  });\n\n  return function resolveBodyLength(_x3, _x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nexport default isFetchSupported && /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (config) {\n    let {\n      url,\n      method,\n      data,\n      signal,\n      cancelToken,\n      timeout,\n      onDownloadProgress,\n      onUploadProgress,\n      responseType,\n      headers,\n      withCredentials = 'same-origin',\n      fetchOptions\n    } = resolveConfig(config);\n    responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n    let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n    let request;\n\n    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {\n      composedSignal.unsubscribe();\n    });\n\n    let requestContentLength;\n\n    try {\n      if (onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' && (requestContentLength = yield resolveBodyLength(headers, data)) !== 0) {\n        let _request = new Request(url, {\n          method: 'POST',\n          body: data,\n          duplex: \"half\"\n        });\n\n        let contentTypeHeader;\n\n        if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n          headers.setContentType(contentTypeHeader);\n        }\n\n        if (_request.body) {\n          const [onProgress, flush] = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress)));\n          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n        }\n      }\n\n      if (!utils.isString(withCredentials)) {\n        withCredentials = withCredentials ? 'include' : 'omit';\n      } // Cloudflare Workers throws when credentials are defined\n      // see https://github.com/cloudflare/workerd/issues/902\n\n\n      const isCredentialsSupported = (\"credentials\" in Request.prototype);\n      request = new Request(url, { ...fetchOptions,\n        signal: composedSignal,\n        method: method.toUpperCase(),\n        headers: headers.normalize().toJSON(),\n        body: data,\n        duplex: \"half\",\n        credentials: isCredentialsSupported ? withCredentials : undefined\n      });\n      let response = yield fetch(request);\n      const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n\n      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {\n        const options = {};\n        ['status', 'statusText', 'headers'].forEach(prop => {\n          options[prop] = response[prop];\n        });\n        const responseContentLength = utils.toFiniteNumber(response.headers.get('content-length'));\n        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [];\n        response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {\n          flush && flush();\n          unsubscribe && unsubscribe();\n        }), options);\n      }\n\n      responseType = responseType || 'text';\n      let responseData = yield resolvers[utils.findKey(resolvers, responseType) || 'text'](response, config);\n      !isStreamResponse && unsubscribe && unsubscribe();\n      return yield new Promise((resolve, reject) => {\n        settle(resolve, reject, {\n          data: responseData,\n          headers: AxiosHeaders.from(response.headers),\n          status: response.status,\n          statusText: response.statusText,\n          config,\n          request\n        });\n      });\n    } catch (err) {\n      unsubscribe && unsubscribe();\n\n      if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {\n        throw Object.assign(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request), {\n          cause: err.cause || err\n        });\n      }\n\n      throw AxiosError.from(err, err && err.code, config, request);\n    }\n  });\n\n  return function (_x5) {\n    return _ref4.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["D:/Users/jenif/Documents/linguagens_prog/javascript/API - angular e nest/estoque/estoqueFront/node_modules/axios/lib/adapters/fetch.js"],"names":["platform","utils","AxiosError","composeSignals","trackStream","AxiosHeaders","progressEventReducer","progressEventDecorator","asyncDecorator","resolveConfig","settle","isFetchSupported","fetch","Request","Response","isReadableStreamSupported","ReadableStream","encodeText","TextEncoder","encoder","str","encode","Uint8Array","arrayBuffer","test","fn","args","e","supportsRequestStream","duplexAccessed","hasContentType","origin","body","method","duplex","headers","has","DEFAULT_CHUNK_SIZE","supportsResponseStream","isReadableStream","resolvers","stream","res","forEach","type","isFunction","_","config","ERR_NOT_SUPPORT","getBodyLength","isBlob","size","isSpecCompliantForm","_request","byteLength","isArrayBufferView","isArrayBuffer","isURLSearchParams","isString","resolveBodyLength","length","toFiniteNumber","getContentLength","url","data","signal","cancelToken","timeout","onDownloadProgress","onUploadProgress","responseType","withCredentials","fetchOptions","toLowerCase","composedSignal","toAbortSignal","request","unsubscribe","requestContentLength","contentTypeHeader","isFormData","get","setContentType","onProgress","flush","isCredentialsSupported","prototype","toUpperCase","normalize","toJSON","credentials","undefined","response","isStreamResponse","options","prop","responseContentLength","responseData","findKey","Promise","resolve","reject","from","status","statusText","err","name","message","Object","assign","ERR_NETWORK","cause","code"],"mappings":"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","sourcesContent":["import platform from \"../platform/index.js\";\nimport utils from \"../utils.js\";\nimport AxiosError from \"../core/AxiosError.js\";\nimport composeSignals from \"../helpers/composeSignals.js\";\nimport {trackStream} from \"../helpers/trackStream.js\";\nimport AxiosHeaders from \"../core/AxiosHeaders.js\";\nimport {progressEventReducer, progressEventDecorator, asyncDecorator} from \"../helpers/progressEventReducer.js\";\nimport resolveConfig from \"../helpers/resolveConfig.js\";\nimport settle from \"../core/settle.js\";\n\nconst isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';\nconst isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';\n\n// used only inside the fetch adapter\nconst encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?\n    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :\n    async (str) => new Uint8Array(await new Response(str).arrayBuffer())\n);\n\nconst test = (fn, ...args) => {\n  try {\n    return !!fn(...args);\n  } catch (e) {\n    return false\n  }\n}\n\nconst supportsRequestStream = isReadableStreamSupported && test(() => {\n  let duplexAccessed = false;\n\n  const hasContentType = new Request(platform.origin, {\n    body: new ReadableStream(),\n    method: 'POST',\n    get duplex() {\n      duplexAccessed = true;\n      return 'half';\n    },\n  }).headers.has('Content-Type');\n\n  return duplexAccessed && !hasContentType;\n});\n\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\n\nconst supportsResponseStream = isReadableStreamSupported &&\n  test(() => utils.isReadableStream(new Response('').body));\n\n\nconst resolvers = {\n  stream: supportsResponseStream && ((res) => res.body)\n};\n\nisFetchSupported && (((res) => {\n  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n    !resolvers[type] && (resolvers[type] = utils.isFunction(res[type]) ? (res) => res[type]() :\n      (_, config) => {\n        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);\n      })\n  });\n})(new Response));\n\nconst getBodyLength = async (body) => {\n  if (body == null) {\n    return 0;\n  }\n\n  if(utils.isBlob(body)) {\n    return body.size;\n  }\n\n  if(utils.isSpecCompliantForm(body)) {\n    const _request = new Request(platform.origin, {\n      method: 'POST',\n      body,\n    });\n    return (await _request.arrayBuffer()).byteLength;\n  }\n\n  if(utils.isArrayBufferView(body) || utils.isArrayBuffer(body)) {\n    return body.byteLength;\n  }\n\n  if(utils.isURLSearchParams(body)) {\n    body = body + '';\n  }\n\n  if(utils.isString(body)) {\n    return (await encodeText(body)).byteLength;\n  }\n}\n\nconst resolveBodyLength = async (headers, body) => {\n  const length = utils.toFiniteNumber(headers.getContentLength());\n\n  return length == null ? getBodyLength(body) : length;\n}\n\nexport default isFetchSupported && (async (config) => {\n  let {\n    url,\n    method,\n    data,\n    signal,\n    cancelToken,\n    timeout,\n    onDownloadProgress,\n    onUploadProgress,\n    responseType,\n    headers,\n    withCredentials = 'same-origin',\n    fetchOptions\n  } = resolveConfig(config);\n\n  responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n\n  let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n\n  let request;\n\n  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {\n      composedSignal.unsubscribe();\n  });\n\n  let requestContentLength;\n\n  try {\n    if (\n      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&\n      (requestContentLength = await resolveBodyLength(headers, data)) !== 0\n    ) {\n      let _request = new Request(url, {\n        method: 'POST',\n        body: data,\n        duplex: \"half\"\n      });\n\n      let contentTypeHeader;\n\n      if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n        headers.setContentType(contentTypeHeader)\n      }\n\n      if (_request.body) {\n        const [onProgress, flush] = progressEventDecorator(\n          requestContentLength,\n          progressEventReducer(asyncDecorator(onUploadProgress))\n        );\n\n        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n      }\n    }\n\n    if (!utils.isString(withCredentials)) {\n      withCredentials = withCredentials ? 'include' : 'omit';\n    }\n\n    // Cloudflare Workers throws when credentials are defined\n    // see https://github.com/cloudflare/workerd/issues/902\n    const isCredentialsSupported = \"credentials\" in Request.prototype;\n    request = new Request(url, {\n      ...fetchOptions,\n      signal: composedSignal,\n      method: method.toUpperCase(),\n      headers: headers.normalize().toJSON(),\n      body: data,\n      duplex: \"half\",\n      credentials: isCredentialsSupported ? withCredentials : undefined\n    });\n\n    let response = await fetch(request);\n\n    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n\n    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {\n      const options = {};\n\n      ['status', 'statusText', 'headers'].forEach(prop => {\n        options[prop] = response[prop];\n      });\n\n      const responseContentLength = utils.toFiniteNumber(response.headers.get('content-length'));\n\n      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(\n        responseContentLength,\n        progressEventReducer(asyncDecorator(onDownloadProgress), true)\n      ) || [];\n\n      response = new Response(\n        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {\n          flush && flush();\n          unsubscribe && unsubscribe();\n        }),\n        options\n      );\n    }\n\n    responseType = responseType || 'text';\n\n    let responseData = await resolvers[utils.findKey(resolvers, responseType) || 'text'](response, config);\n\n    !isStreamResponse && unsubscribe && unsubscribe();\n\n    return await new Promise((resolve, reject) => {\n      settle(resolve, reject, {\n        data: responseData,\n        headers: AxiosHeaders.from(response.headers),\n        status: response.status,\n        statusText: response.statusText,\n        config,\n        request\n      })\n    })\n  } catch (err) {\n    unsubscribe && unsubscribe();\n\n    if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {\n      throw Object.assign(\n        new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),\n        {\n          cause: err.cause || err\n        }\n      )\n    }\n\n    throw AxiosError.from(err, err && err.code, config, request);\n  }\n});\n\n\n"]},"metadata":{},"sourceType":"module"}